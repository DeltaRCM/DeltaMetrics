import abc

import numpy as np
from scipy import stats, sparse

import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable


from . import cube
from . import plot


class BaseSectionVariable(np.ma.MaskedArray):
    """Section variable.

    We subclass the numpy MaskedArray, in order to add `ndarray` methods to
    the object in subclasses.

    This is a really lightweight subclass of the MaskedArray, but it allows us
    to flip the mask from "preserved" to "bad data" for the MA. We also gain
    the ability to return the correct subclass type following views and
    slicing of the subclasses.

    .. note::

        Subclasses should implement the ``__init__`` method.

    """

    def __new__(cls, _data, _mask, *unused_args, **unused_kwargs):
        """Construct the array from _data.

        In this section we validate the inputs, and then apply the mask
        """
        obj = np.asarray(_data).view(cls)
        obj._mask = ~_mask
        return obj

    def __array_finalize__(self, obj):
        super().__array_finalize__(obj)

    def __getitem__(self, item):
        return self._data[item]

    @property
    def t(self):
        return self._t

    @property
    def z(self):
        return self._z


class DataSectionVariable(BaseSectionVariable):
    """Variable returned from a DataCube Section.

    Subclasses numpy MaskedArray, so supports arbitrary math.

    .. note::
        ``__new__`` from the base class is called *before* __init__.

    """
    def __init__(self, _data, _mask, strat_attrs):
        """Construct the array from section info.

        Parameters
        ----------
        _data : :obj:`ndarray`
            Slice of underlying data. Generated by slicing the CubeVariable
            with: :code:`cube[var][:, self._y, self._x]`

        _mask : :obj:`ndarray`
            Mask indicating the *preserved* voxels. Must have same shape as
            `_data`.

        strat_attrs : :obj:`dict`
            Dictionary of attributes regarding stratigraphy generated by the
            section, on instantiation. May be a nearly empty dictionary, but
            must always be provided. Only used if
            `Section._knows_stratigraphy`.

        Notes
        -----

        Some descriptions regarding implementation.

        _psvd_idx : :obj:`ndarray` of `np.bool`
            Preserved index into the section array.

        _psvd_flld : :obj:`ndarray`
            Elevation of preserved voxels, filled to vertical extent with the
            final elevation of the bed (i.e., to make it displayable by
            pcolormesh).

        _i : :obj:`ndarray`
            Row index for sparse matrix of preserved strata. I.e., which row
            in the stratigraphy matrix each voxel "winds up as".

        _j : :obj:`ndarray`
            Column index for sparse matrix of preserved strata. I.e., which
            column in the stratigraphy matrix each voxel "winds up as". This
            is kind of just a dummy to make the api consistent with ``_i``,
            because the column cannot change with preservation.

        """
        self._knows_stratigraphy = strat_attrs['knows_stratigraphy']
        _psvd_idx = _mask

        if self._knows_stratigraphy:
            _psvd_flld = strat_attrs['psvd_flld']
            _i = strat_attrs['i']
            _j = strat_attrs['j']
            self._psvd_data = _data[_psvd_idx]  # actual data, where preserved
            self._s = _j[0, :]                  # along-section coord
            self._s_sp = _j[_psvd_idx]          # along-section coord, sparse
            self._z_sp = _i[_psvd_idx]          # vertical coord, sparse
            self._sp = sparse.coo_matrix((self._psvd_data,
                                          (self._z_sp, self._s_sp)))
            self._psvd_flld = _psvd_flld[:self._sp.shape[0], ...]

    def as_spacetime(self, preserved=False):
        """Spacetime matrix.

        Return section data as a full matrix of space-and-time values.

        Parameters
        ----------
        preserved : :obj:`bool`
            Whether to return only the preserved data. Default returns
            everything (False).

        Returns
        -------
        None
        """

        if preserved:
            if not self._knows_stratigraphy:
                raise AttributeError('No preservation information.')
            return self
        else:
            return self._data.view(DataSectionVariable)

    def as_stratigraphy(self, style='mesh'):
        """Preserved strata.

        Return section data as a collapsed matrix of values, stacked directly
        atop one another. This matrix can be combined with preserved elevation
        values to create a presentable section slice (see
        :meth:`~deltametrics.section.BaseSection.show`).

        Parameters
        ----------
        style : :obj:`str`, optional
            Which style of stratigraphy to return. Default is ``'mesh'``.

            .. warning::
                No other options implemented currently, but should support
                returning boxy stratigraphy.

        Returns
        -------
        arr : :obj:`ndarray`
            The SectionVariable represented as stratigraphy.

            .. note::

                This array is not suitable to be displayed directly as
                stratigraphy. It must be plotted with s-z coordinates of the
                entries in the array, to display correctly as stratigraphy.
        """
        if not self._knows_stratigraphy:
            raise AttributeError('No stratigraphy information.')
        if style == 'mesh':
            return self._sp.toarray().view(DataSectionVariable)
        elif style == 'boxy':
            raise NotImplementedError


class StratigraphySectionVariable(BaseSectionVariable):
    """
    """
    def __init__(self, *args, **kwargs):
        raise NotImplementedError


class BaseSection(abc.ABC):
    """Base section object.

    Defines common attributes and methods of a section object.

    This object should wrap around many of the functions available from
    :obj:`~deltametrics.strat`.

    """

    def __init__(self, *args):
        """
        Identify coordinates defining the section.

        Parameters
        ----------
        CubeInstance : :obj:`~deltametrics.cube.Cube` subclass instance, optional
            Connect to this cube. No connection is made if cube is not provided.

        Notes
        -----

        If no arguments are passed, and empty section is returned, which is
        not connected to any cube, and will need to be manually connected to
        have any functionality.
        """

        self.cube = None  # begin unconnected

        if len(args) > 1:
            raise ValueError('Expected single argument to %s instantiation.'
                             % type(self))

        if len(args) > 0:
            self.connect(args[0])
        else:
            pass

    def connect(self, CubeInstance):
        """Connect this Section instance to a Cube instance.
        """
        if not issubclass(type(CubeInstance), cube.BaseCube):
            raise TypeError('Expected type was {_exptype}, '
                            'but received was {_gottype}.'.format(
                                _exptype=type(cube.Cube),
                                _gottype=type(CubeInstance)))
        self.cube = CubeInstance
        self._variables = self.cube.variables
        self._compute_section_coords()
        self._compute_section_attrs()

    @abc.abstractmethod
    def _compute_section_coords(self):
        """Should calculate x-y coordinates of the section.

        Sets the value ``self._x`` and ``self._y`` according to the algorithm
        of each section initialization.

        .. warning::

            Be sure that ``self._x`` and ``self._y`` are *one-dimensional
            arrays*, or you will get an improperly shaped Section array in
            return.
        """

        return

    def _compute_section_attrs(self):
        """Compute attrs

        Compute the down-strike coordinate array from x-y pts pairs definining
        the section.
        """

        self._s = np.hstack((0, np.sqrt((self._x[1:] - self._x[:-1])**2
                                       + (self._y[1:] - self._y[:-1])**2)))
        self.strat_attrs = {}
        if type(self.cube) is cube.DataCube:
            if self.cube._knows_stratigraphy:
                self.strat_attrs['knows_stratigraphy'] = True
                self.strat_attrs['i'] = self.cube._psvd_vxl_idx[:, self._y, self._x]
                _i = self.strat_attrs['i']
                self.strat_attrs['j'] = np.tile(np.arange(_i.shape[1]), (_i.shape[0], 1))
                self.strat_attrs['psvd_idx'] = self.cube._psvd_idx[:, self._y, self._x]
                self.strat_attrs['psvd_flld'] = self.cube._psvd_flld[:, self._y, self._x]
            else:
                self.strat_attrs['knows_stratigraphy'] = False
        elif type(self.cube) is cube.StratigraphyCube:
            self.strat_attrs['psvd_idx'] = np.ones_like(self.sectionshape)
        else:
            # this would be for other types (?)
            raise TypeError

    @property
    def trace(self):
        """Coordinates of the section in the x-y plane.
        """
        return np.column_stack((self._x, self._y))

    @property
    def s(self):
        return self._s

    @property
    def variables(self):
        """List of variables.
        """
        return self._variables

    def __getitem__(self, var):
        """Get a slice of the section.

        Slicing the section instance creates a
        :obj:`~deltametrics.section.SectionVariable` instance from data for
        variable ``var``.

        .. note:: We only support slicing by string.

        Parameters
        ----------
        var : :obj:`str`
            Which variable to slice.

        Returns
        -------
        SectionVariable : :obj:`~deltametrics.section.SectionVariable` instance
            SectionVariable instance for variable ``var``.
        """

        if type(self.cube) is cube.DataCube:
            if self.cube._knows_stratigraphy:
                return DataSectionVariable(_data=self.cube[var][:, self._y, self._x],
                                           _mask=self.cube._psvd_idx[:, self._y, self._x],
                                           strat_attrs=self.strat_attrs)
            else:
                return DataSectionVariable(_data=self.cube[var][:, self._y, self._x],
                                           _mask=np.ones_like(self.cube[var][:, self._y, self._x], dtype=np.bool),
                                           strat_attrs=self.strat_attrs)
        elif type(self.cube) is cube.StratigraphyCube:
            return StratigraphySectionVariable(_data=self.cube[var][:, self._y, self._x],
                                               _mask=np.ones_like(self.cube[var][:, self._y, self._x], dtype=np.bool),
                                               strat_attrs=self.strat_attrs)
        elif self.cube is None:
            raise AttributeError('No cube connected. Are you sure you ran `.connect()`?')
        else:
            raise TypeError('Unknown Cube type encountered: %s'
                            % type(self.cube))

    def show(self, SectionAttribute, style='mesh', **kwargs):
        """Show the section.

        .. warning::
            The documentation around this method is not correct. Many
            unsupported features are listed. Need to impplement all options,
            then document with examples and tests.

        Parameters
        ----------

        SectionAttribute : :obj:`str`
            Which attribute to show.

        style : :obj:`str`, optional
            What style to display the section with. Choices are 'mesh' or 'line'.

        **kwargs
            Passed to matplotlib plotting functions.

            .. warning:: Not implemented.

        Examples
        --------


        """

        t = kwargs.pop('t', [])
        ax = kwargs.pop('ax', None)
        ticks = kwargs.pop('ticks', False)
        origin = kwargs.pop('origin', 'lower')
        as_strata = kwargs.pop('as_strata', True)
        if not ax:
            ax = plt.gca()

        if hasattr(self, 'cube'):
            _varinfo = self.cube.varset[SectionAttribute]
        else:
            _varinfo = utils.VariableSet()[SectionAttribute]

        SectionVariableInstance = self[SectionAttribute]

        if style == 'mesh':
            _arr = SectionVariableInstance.as_stratigraphy()
            _arr_Y = SectionVariableInstance._psvd_flld
            _arr_X = np.tile(SectionVariableInstance._s, (_arr.shape[0], 1))
            # print("_s shape:", SectionVariableInstance._s.shape)
            # print("_arr:", _arr.shape)
            # print("_arr_Y:", _arr_Y.shape)
            # print("_arr_X:", _arr_X.shape)
            pcm = ax.pcolormesh(_arr_X, _arr_Y, _arr,
                                cmap=_varinfo.cmap,
                                norm=_varinfo.norm,
                                vmin=_varinfo.vmin,
                                vmax=_varinfo.vmax,
                                rasterized=True)
            cb = plot.append_colorbar(pcm, ax)
            cb.ax.tick_params(labelsize=7)
            ax.use_sticky_edges = False
            ax.margins(y=0.2)
            ax.text(0.99, 0.8, _varinfo.label, fontsize=8,
                    horizontalalignment='right', verticalalignment='center',
                    transform=ax.transAxes)
        elif style in ['line', 'lines']:
            raise NotImplementedError
            _arr = SectionVariableInstance
            nt = _arr.shape[0]
            cmap = plt.cm.get_cmap('viridis', nt)
            for t in np.arange(nt):
                ax.plot(np.arange(_arr.shape[1]), _arr[t, :], c=cmap(t))
            # create a fake colormapper to pass to append colorbar that mimes
            # the colors of the lines


class PathSection(BaseSection):
    """Path section object.

    Create a Section along user-specified path.

    .. note::

        Currently, this extracts only *at* the points specified. A good
        improvement would be to interpolate along the path defined, and
        extract the section everywhere the path intersects within 50% of the
        center of the surface area of a grid cell.
    """

    def __init__(self, *args, path):
        """Instantiate.

        Parameters
        ----------
        path : :obj:`ndarray`
            An Mx2 `ndarray` specifying the x-y pairs of coordinates to
            extract the section from.

        Notes
        -----

        `path` must be supplied as a keyword argument.

        """

        self._path = path

        super().__init__(*args)

    def _compute_section_coords(self):
        """Calculate coordinates of the strike section.
        """

        self._x = self._path[:, 1]
        self._y = self._path[:, 0]

    @property
    def path(self):
        """Path of the PathSection.

        Returns same as `trace` property, but setter validates some settings.
        """
        return self._trace


class StrikeSection(BaseSection):
    """Strike section object.
    """

    def __init__(self, *args, y=0):

        self.y = y  # strike coord scalar

        super().__init__(*args)

    def _compute_section_coords(self):
        """Calculate coordinates of the strike section.
        """

        _nx = self.cube['eta'].shape[2]
        self._x = np.arange(_nx)
        self._y = np.tile(self.y, (_nx))


class DipSection(BaseSection):
    """Dip section object.

    """

    def __init__(self, apex, angle):
        pass


class RadialSection(BaseSection):
    """Radial section object.

    """

    def __init__(self, apex, radius):
        pass
