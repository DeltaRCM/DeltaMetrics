import abc

import numpy as np
from scipy import stats, sparse

import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable


from . import cube
from . import plot


class SectionVariableMA(np.ma.MaskedArray):
    """Section variable.

    We subclass the numpy MaskedArray, in order to add `ndarray` methods to
    the object.

    I think this is the preferred way of handling the section variable, but I
    need to get it implemented correctly to use the numpy C libraries still.

    .. warning:: NOT IMPLEMENTED
    """

    def __new__(cls, _arr, _preserved,
                _preserved_voxel_count, _preserved_voxel_eta,
                _preserved_height):
        """Construct the array from _arr.

        In this section we validate the inputs, and then apply the mask
        """
        obj = np.asarray(_arr).view(cls)
        obj._mask = ~_preserved
        # obj._is_spacetime = True
        obj._preserved_voxel_count = _preserved_voxel_count
        obj._preserved_voxel_eta = _preserved_voxel_eta
        obj._preserved_height = int(_preserved_height)
        nx = obj._data.shape[1]
        obj._strata = np.zeros(shape=(obj._preserved_height + 1, nx))
        for j in np.arange(nx):
            obj._strata[0:obj._preserved_voxel_count[j], j] = obj._data[
                0:obj._preserved_voxel_count[j], j]
        return obj

    def __array_finalize__(self, obj):
        if obj is None:
            return
        self._mask = getattr(obj, '_mask', None)
        self._preserved_voxel_count = getattr(
            obj, '_preserved_voxel_count', None)
        self._preserved_height = getattr(obj, '_preserved_height', None)
        self._preserved_voxel_eta = getattr(obj, '_preserved_voxel_eta', None)
        super().__array_finalize__(obj)

    def __getitem__(self, item):
        return self._data[item]

    def as_spacetime(self):
        return self._data

    def as_strata(self):
        return self._strata


class SectionVariable(object):
    """Section variable.

        This could be one way to implement functionality of section
        variables. We would have to implement all the functionality of the
        ndarray ourselves. It's more readable to do it this way, but much
        more labor and maintainence intensive. I suggest we subclass the
        MaskedArray.

    """

    def __init__(self, _data, _psvd_idx,
                 _psvd_flld, _i, _j):
        """Construct the array from section info.

        Parameters
        ----------
        _data : :obj:`ndarray`
            Slice of underlying data. Generated by slicing the CubeVariable
            with: :code:`cube[var][:, self._y, self._x]`

        _psvd_idx : :obj:`ndarray` of `np.bool`
            Preserved index into the section array.

        _psvd_flld : :obj:`ndarray`
            Elevation of preserved voxels, filled to vertical extent with the
            final elevation of the bed (i.e., to make it displayable by
            pcolormesh).

        _i : :obj:`ndarray`
            Row index for sparse matrix of preserved strata. I.e., which row
            in the stratigraphy matrix each voxel "winds up as".

        _j : :obj:`ndarray`
            Column index for sparse matrix of preserved strata. I.e., which column
            in the stratigraphy matrix each voxel "winds up as". This is kind
            of just a dummy to make the api consistent with ``_i``, because
            the column cannot change with preservation.

        """
        self._data = np.ma.MaskedArray(_data, ~_psvd_idx)
        self._mask = self._data._mask

        self._psvd_data = _data[_psvd_idx]  # actual data, where preserved
        self._s = _j[0, :]                  # along-section coord
        self._s_sp = _j[_psvd_idx]          # along-section coord, sparse
        self._z_sp = _i[_psvd_idx]          # vertical coord, sparse
        self._sp = sparse.coo_matrix((self._psvd_data,
                                      (self._z_sp, self._s_sp)))
        self._psvd_flld = _psvd_flld[:self._sp.shape[0], ...]


    def __getitem__(self, item):
        return self._data[item]

    def __add__(self, other):
        """Pass to underlying array.

        .. note::

            This is an example of what could be implemented for ops. Downside
            is that it returns a MaskedArray and not a SectionVariable.
        """
        return self._data + other

    def as_spacetime(self, preserved=False):
        """Spacetime matrix.

        Return section data as a full matrix of space-and-time values.

        Parameters
        ----------
        preserved : :obj:`bool`
            Whether to return only the preserved data. Default returns
            everything (False).

        Returns
        -------
        None
        """
        if preserved:
            return self._data
        else:
            return self._data._data

    def as_stratigraphy(self):
        """Preserved strata.

        Return section data as a collapsed matrix of values, stacked directly
        atop one another. This matrix can be combined with preserved elevation
        values to create a presentable section slice (see
        :meth:`~deltametrics.section.BaseSection.show`).

        Parameters
        ----------
        None

        Returns
        -------
        arr : :obj:`ndarray`
            The SectionVariable represented as stratigraphy.

            .. note::

                This array is not suitable to be displayed directly as
                stratigraphy. It must be plotted with s-z coordinates of the
                entries in the array, to display correctly as stratigraphy.
        """
        return self._sp.toarray()


class BaseSection(abc.ABC):
    """Base section object.

    Defines common attributes and methods of a section object.

    This object should wrap around many of the functions available from
    :obj:`~deltametrics.strat`.

    """

    def __init__(self, *args):
        """
        Extract values from Cube at pts.

        Parameters
        ----------

        pts : `ndarray`, optional
            two column ndarray defining the x-y coordinates to extract the
            section.

        limit : `list`, `ndarray`, optional
            Vertical limits to extract the section over. Use None or np.nan to
            specify the lowermost or uppermost lines. Default is to extract
            full section.

        Notes
        -----

        If no arguments are passed, and empty section is returned, which is
        not connected to any cube, and will need to be manually connected to
        have any functionality.

        ``limit`` option is not implemented currently.

        """
        if len(args) > 0:
            self._coords = self._compute_section_coords()
        else:
            pass

    @abc.abstractmethod
    def _compute_section_coords(self):
        """Should calculate x-y coordinates of the section.
        """
        return

    @property
    def coords(self):
        return self._coords

    @property
    def variables(self):
        """List of variables.
        """
        return self._variables

    def __getitem__(self, var):
        """Get a slice of the section.

        Slicing the section instance creates a
        :obj:`~deltametrics.section.SectionVariable` instance from data for
        variable ``var``.

        .. note:: We only support slicing by string.

        Parameters
        ----------
        var : :obj:`str`
            Which variable to slice.

        Returns
        -------
        SectionVariable : :obj:`~deltametrics.section.SectionVariable` instance
            SectionVariable instance for variable ``var``.
        """

        #  get the info to construct the stratigraphy sparse array
        _i = self.cube._psvd_vxl_idx[:, self._y, self._x]
        _j = np.tile(np.arange(_i.shape[1]), (_i.shape[0], 1))

        return SectionVariable(_data=self.cube[var][:, self._y, self._x],
                               _psvd_idx=self.cube._psvd_idx[
                                   :, self._y, self._x],
                               _psvd_flld=self.cube._psvd_flld[
                                   :, self._y, self._x],
                               _i=_i, _j=_j)

    def _compute_section_attrs(self):
        """Compute attrs

        Compute the down-strike coordinate array from x-y pts pairs definining
        the section.
        """
        pass

    def connect(self, _cube):
        """Connect this Section instance to a Cube instance.
        """
        if not type(_cube) is cube.Cube:
            raise TypeError('Expected type was {_exptype}, but received was {_gottype}.'
                            .format(_exptype=type(cube.Cube), _gottype=type(_cube)))
        self.cube = _cube
        self._variables = self.cube.variables
        self._compute_section_coords()
        self._compute_section_attrs()
        # self.preserved_index = self.cube.preserved_index

    def show(self, SectionAttribute, style='mesh', **kwargs):
        """Show the section.

        .. warning::
            The documentation around this method is not correct. Many
            unsupported features are listed. Need to impplement all options,
            then document with examples and tests.

        Parameters
        ----------

        SectionAttribute : :obj:`str`
            Which attribute to show.

        style : :obj:`str`, optional
            What style to display the section with. Choices are 'mesh' or 'line'.

        **kwargs
            Passed to matplotlib plotting functions. 

            .. warning:: Not implemented.

        Examples
        --------


        """

        t = kwargs.pop('t', [])
        ax = kwargs.pop('ax', None)
        ticks = kwargs.pop('ticks', False)
        origin = kwargs.pop('origin', 'lower')
        as_strata = kwargs.pop('as_strata', True)
        if not ax:
            ax = plt.gca()

        if hasattr(self, 'cube'):
            _varinfo = self.cube.varset[SectionAttribute]
        else:
            _varinfo = utils.VariableSet()[SectionAttribute]

        SectionVariable = self[SectionAttribute]

        if style == 'mesh':
            _arr = SectionVariable.as_stratigraphy()
            _arr_Y = SectionVariable._psvd_flld
            _arr_X = np.tile(SectionVariable._s, (_arr.shape[0], 1))
            # print("_s shape:", SectionVariable._s.shape)
            # print("_arr:", _arr.shape)
            # print("_arr_Y:", _arr_Y.shape)
            # print("_arr_X:", _arr_X.shape)
            pcm = ax.pcolormesh(_arr_X, _arr_Y, _arr,
                                cmap=_varinfo.cmap,
                                norm=_varinfo.norm,
                                vmin=_varinfo.vmin,
                                vmax=_varinfo.vmax)
            cb = plot.append_colorbar(pcm, ax)
            cb.ax.tick_params(labelsize=7)
            ax.use_sticky_edges = False
            ax.margins(y=0.2)
            ax.text(0.99, 0.8, _varinfo.label, fontsize=8,
                    horizontalalignment='right', verticalalignment='center',
                    transform=ax.transAxes)
        elif style in ['line', 'lines']:
            raise NotImplementedError
            _arr = SectionVariable
            nt = _arr.shape[0]
            cmap = plt.cm.get_cmap('viridis', nt)
            for t in np.arange(nt):
                ax.plot(np.arange(_arr.shape[1]), _arr[t, :], c=cmap(t))
            # create a fake colormapper to pass to append colorbar that mimes
            # the colors of the lines


class StrikeSection(BaseSection):
    """Strike section object.

    """

    def __init__(self, *args, y=0):

        self.y = y

        super().__init__(*args)

    def _compute_section_coords(self):
        """Calculate coordinates of the strike section.

        .. warning::
            Need to reimplement this to return as generic Mx2 list of X-Y pairs.

        """
        # pts = np.column_stack((np.arange(self.cube['x'].shape[1]),
        #                        self.y * np.ones(self.cube['x'].shape[1])))
        self._x = np.arange(self.cube['x'].shape[1])
        self._y = self.y  # * np.ones(self.cube['x'].shape[1], dtype=np.int)
        # return np.ravel_multi_index((_x, _y), self.cube['x'].shape)
        # print(np.vstack((_y, _x)))
        # return np.ravel_multi_index(np.vstack((_y, _x)),
        # self.cube['x'].shape)


class DipSection(BaseSection):
    """Dip section object.

    """

    def __init__(self, apex, angle):
        pass


class RadialSection(BaseSection):
    """Radial section object.

    """

    def __init__(self, apex, radius):
        pass
